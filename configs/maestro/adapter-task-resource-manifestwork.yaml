# ManifestWork Template for External Reference
# File: manifestwork-ref.yaml
#
# This template file defines the ManifestWork structure that wraps Kubernetes manifests
# for deployment via Maestro transport. It's referenced from business logic configs
# using the 'ref' approach for clean separation of concerns.
#
# Template Variables Available:
# - .clusterId: Target cluster identifier
# - .generationId: Resource generation for conflict resolution
# - .adapterName: Name of the adapter creating this ManifestWork
# - .placementCluster: Target cluster name (becomes ManifestWork namespace)
# - .timestamp: Creation timestamp
# - .manifests: Array of rendered Kubernetes manifests (injected by framework)

apiVersion: work.open-cluster-management.io/v1
kind: ManifestWork
metadata:
  # ManifestWork name - must be unique within consumer namespace
  name: "hyperfleet-cluster-setup-{{ .clusterId }}"

  # Labels for identification, filtering, and management
  labels:
    # HyperFleet tracking labels
    hyperfleet.io/cluster-id: "{{ .clusterId }}"
    hyperfleet.io/adapter: "{{ .adapterName }}"
    hyperfleet.io/component: "infrastructure"
    hyperfleet.io/generation: "{{ .generationId }}"
    hyperfleet.io/resource-group: "cluster-setup"

    # Maestro-specific labels
    maestro.io/source-id: "{{ .adapterName }}"
    maestro.io/resource-type: "manifestwork"
    maestro.io/priority: "normal"

    # Standard Kubernetes application labels
    app.kubernetes.io/name: "aro-hcp-cluster"
    app.kubernetes.io/instance: "{{ .clusterId }}"
    app.kubernetes.io/version: "v1.0.0"
    app.kubernetes.io/component: "infrastructure"
    app.kubernetes.io/part-of: "hyperfleet"
    app.kubernetes.io/managed-by: "hyperfleet-adapter"
    app.kubernetes.io/created-by: "{{ .adapterName }}"

  # Annotations for metadata and operational information
  annotations:
    # Tracking and lifecycle
    hyperfleet.io/created-by: "hyperfleet-adapter-framework"
    hyperfleet.io/managed-by: "{{ .adapterName }}"
    hyperfleet.io/generation: "{{ .generationId }}"
    hyperfleet.io/cluster-name: "{{ .clusterId }}"
    hyperfleet.io/deployment-time: "{{ .timestamp }}"

    # Maestro-specific annotations
    maestro.io/applied-time: "{{ .timestamp }}"
    maestro.io/source-adapter: "{{ .adapterName }}"

    # Operational annotations
    deployment.hyperfleet.io/strategy: "rolling"
    deployment.hyperfleet.io/timeout: "300s"
    monitoring.hyperfleet.io/enabled: "true"

    # Documentation
    description: "Complete cluster setup including namespace, configuration, and RBAC"
    documentation: "https://docs.hyperfleet.io/adapters/aro-hcp"

# ManifestWork specification
spec:
  # ============================================================================
  # Workload - Contains the Kubernetes manifests to deploy
  # ============================================================================
  workload:
    # Kubernetes manifests array - injected by framework from business logic config
    manifests:
    - apiVersion: v1
      kind: Namespace
      metadata:
        name: "{{ .clusterId | lower }}"
        labels:
          hyperfleet.io/cluster-id: "{{ .clusterId }}"
          hyperfleet.io/managed-by: "{{ .metadata.name }}"
          hyperfleet.io/resource-type: "namespace"
        annotations:
          hyperfleet.io/created-by: "hyperfleet-adapter"
          hyperfleet.io/generation: "{{ .generationId }}"
    - apiVersion: v1
      kind: ConfigMap
      metadata:
        name: "cluster-config"
        namespace: "{{ .clusterId }}"
        labels:
          hyperfleet.io/cluster-id: "{{ .clusterId }}"
        annotations:
          hyperfleet.io/generation: "{{ .generationId }}"
      data:
        cluster_id: "{{ .clusterId }}"
        cluster_name: "{{ .clusterName }}"

  # ============================================================================
  # Delete Options - How resources should be removed
  # ============================================================================
  deleteOption:
    # Propagation policy for resource deletion
    # - "Foreground": Wait for dependent resources to be deleted first
    # - "Background": Delete immediately, let cluster handle dependents
    # - "Orphan": Leave resources on cluster when ManifestWork is deleted
    propagationPolicy: "Foreground"

    # Grace period for graceful deletion (seconds)
    gracePeriodSeconds: 30

  # ============================================================================
  # Manifest Configurations - Per-resource settings for update and feedback
  # ============================================================================
  manifestConfigs:
    # ========================================================================
    # Configuration for Namespace resources
    # ========================================================================
    - resourceIdentifier:
        group: ""                           # Core API group (empty for v1 resources)
        resource: "namespaces"              # Resource type
        name: "{{ .clusterId | lower }}"    # Specific resource name
      updateStrategy:
        type: "ServerSideApply"             # Use server-side apply for namespaces
        serverSideApply:
          fieldManager: "hyperfleet-adapter" # Field manager name for conflict resolution
          force: false                      # Don't force conflicts (fail on conflicts)
      feedbackRules:
        - type: "JSONPaths"                 # Use JSON path expressions for status feedback
          jsonPaths:
            - name: "phase"                 # Namespace phase (Active, Terminating)
              path: ".status.phase"
            - name: "conditions"            # Namespace conditions array
              path: ".status.conditions"
            - name: "creationTimestamp"     # When namespace was created
              path: ".metadata.creationTimestamp"

 
